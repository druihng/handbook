# Git





## 1.1	关于版本控制

***什么是版本控制 ？*** 

版本控制是一种记录若干文件内容变化，以便将来查找特定版本修订情况的系统。

***为什么我们要关注它 ？***

使用它，我们可以将选定的文件或整个项目回溯到某个时间点的状态，可以比较文件变化细节，可以查出修改人和修改的地方等。它让我们的修改更安全和自动化。



#### 本地版本控制系统

许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。

为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。

![](https://git-scm.com/book/en/v2/images/local.png)

Figure 1. 本地版本控制.

其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 [RCS](https://www.gnu.org/software/rcs/) 的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。



#### 集中化的版本控制系统

接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。

![集中化的版本控制图解](https://git-scm.com/book/en/v2/images/centralized.png)

Figure 2. 集中化的版本控制.

这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。 现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。

事分两面，有好有坏。 这么做最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。



#### 分布式版本控制系统

于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。

![分布式版本控制图解](https://git-scm.com/book/en/v2/images/distributed.png)

Figure 3. 分布式版本控制.

更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。 你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。





## 1.2	Git是什么？

Git 究竟是怎样的一个系统呢？尽管 Git 用起来与其它的版本控制系统非常相似， 但它在对信息的存储和认知方式上却有很大差异，理解这些差异将有助与避免使用中的困惑。



#### 直接记录快照，而非差异比较

Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。 从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统（CVS、Subversion、Perforce、Bazaar 等等） 将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 **基于差异（delta-based）** 的版本控制）。

![存储每个文件与初始版本的差异。](https://git-scm.com/book/en/v2/images/deltas.png)

Figure 4. 存储每个文件与初始版本的差异.

Git 不按照以上方式对待或保存数据。反之，Git 更像是把数据看作是对小型文件系统的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 **快照流**。

![Git 存储项目随时间改变的快照。](https://git-scm.com/book/en/v2/images/snapshots.png)

Figure 5. 存储项目随时间改变的快照.

Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的 VCS。



#### Git保证数据完整性

Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。

Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：

```
24b9da6552252987aa493b52f8696cd6d3b00373
```

Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。



#### Git的目标

* 简单的设计
* 速度
* 完全分布式
* 对非线性开发模式的强力支持（允许成千上万个并行开发的分支）
* 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）



#### Git与SVN的主要比较

**近乎所有操作都是本地执行**

SVN是集中式的版本控制系统，每次提交和访问记录信息都需要连接中心服务器。这意味着你在离线或者没有 VPN 时，几乎不可以进行任何操作，而本地修改的文件也因为暂时失去版本控制的功能而变得危险。没有版本控制功能，修改内容可能会丢失。

Git是完全分布式的，它在每个工作节点都保留有版本控制信息，所以用户对文件的提交和访问记录信息都可以在本地完成。在 Git 中的绝大多数操作都只需要访问本地文件和资源，只有需要协同工作时，才需要和中心服务器交换数据。

**速度**

SVN对待数据的方式是基于差异保存文件内容变更。需要更新本地数据到某个版本时，中心服务器都需要先根据文件的变更列表信息来合并文件补丁，从而生成该版本下对应的文件内容。显然这个合并的过程是需要一定的时间的。合并好该版本下的文件后，再通过网络数据交换，更新到本地。

Git主要是基于文件快照来保存文件变更的，所以更新数据时，Git不需要合并文件补丁。同时这样的更新，Git一般情况下，都是在本地完成，只有需要和中心服务器交换数据时，才需要通过网络来进行数据交换。基于此，Git速度是很快的。

当然，Git针对大文件为了节省存储空间，也是基于文件差异来保存文件变更的，但是项目中这样的大文件相对来说比较少，开发中更多的是文本文件，都比较小。

**分支功能强大**

SVN也有分支功能。SVN的具体操作是，新建分支，然后中心服务器合并文件补丁，再把分支下所有的文件更新到本地。这意味着，SVN新建分支需要花费很长时间。如果项目很大，可能在更新的过程中，你需要极大的耐心，甚至你可以先安排去做其他事。SVN的分支通常被安排在不同的目录下，因此切换不同的分支运行，要到不同的目录下打开项目，这就像分别打开不同的项目一样，同时运行多个IDE主进程。由于SVN分支操作的不便捷，操作成本高，SVN的分支功能通常只会被很有限的使用。

Git新建和切换分支很快，不到1秒就可以完成。Git分支功能强大，它允许成千上万个并行开发的分支。Git是完全分布式的，很多操作一般都在本地完成，只有需要和中心服务交换数据时，才需要连接中心服务。当然Git和中心服务器的数据交换也只是部分有限的交换，Git从中心服务器更新新建的分支，也仅只是更新部分在本地不存在的文件和版本控制信息，这不需要花费很长时间。

在Git分支功能的强大支持下，对于项目可以**轻易**完成不同的策略管理。SVN虽然也可以，但仅仅说明SVN可以做，不代表它能够做好或轻易做到，毕竟SVN的分支功能相比Git很鸡肋，属于半成品。

**安全**

SVN一旦中心服务器出现问题，记录信息有可能就无法恢复。而Git的中心服务器宕机，可以让任意一个工作节点充当中心服务器，同时近乎不会丢失版本控制信息。



#### Git的三种状态

Git 有三种状态，你的文件可能处于其中之一： **已提交（committed）**、**已修改（modified）** 和 **已暂存（staged）**。

- 已修改表示修改了文件，但还没保存到数据库中。
- 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。
- 已提交表示数据已经安全地保存在本地数据库中。

这会让我们的 Git 项目拥有三个阶段：工作区、暂存区以及 Git 目录。

![工作区、暂存区以及 Git 目录。](https://git-scm.com/book/en/v2/images/areas.png)

Figure 6. 工作目录、暂存区域以及 Git 仓库.

工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。

暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。

Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。

基本的 Git 工作流程如下：

1. 在工作区中修改文件。
2. 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。
3. 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。

如果 Git 目录中保存着特定版本的文件，就属于 **已提交** 状态。 如果文件已修改并放入暂存区，就属于 **已暂存** 状态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是 **已修改** 状态。

