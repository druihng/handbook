# 内存管理

一个系统中的进程与其他进程是共享CPU和主存资源的。然而，共享主存会形成一些特殊的挑战。

早期的计算机是没有存储器抽象（**无存储器抽象**）的，每一个程序都直接访问物理内存。直接将物理内存暴露给程序，会带来下面几个严重问题：

* 如果用户程序可以寻址内存的每个字节，它们就可以很容易地破坏操作系统，从而使系统停止运行。
* 想要同时运行多个程序是很困难的。

要使多个程序同时在内存中运行互不影响，需要解决两个问题：保护和重定位。一个好的办法是创造一个存储器抽象：地址空间。地址空间是一个进程可用于寻址内存的一套地址集合，每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间。



## 物理和虚拟寻址

计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的物理地址。
$$
{ 0, 1, 2, ···, m-1}
$$
以此类推，给定这种简单的结构，CPU访问存储器的最自然的方式就是使用物理地址，我们把这种访问方式称为 ***物理寻址（physical adressing）***

图9-1展示了一个物理寻址的示例，该示例的上下文是一条加载指令，它读取从物理地址4处开始的字。

当CPU执行这条加载指令时，它会生成一个有效物理地址，通过存储器总线，把它传递给主存。主存取出从物理地址4处开始的4字节的字，并将它返回给CPU，CPU会将它存放在一个寄存器里。

![aOuyng.png](https://s1.ax1x.com/2020/08/11/aOuyng.png)

早期的PC使用物理寻址，然而现代处理器使用的是一种称为**虚拟寻址**的寻址方式，参见图9-2。

![aOu6BQ.png](https://s1.ax1x.com/2020/08/11/aOu6BQ.png)

使用虚拟寻址时，CPU通过生成一个**虚拟地址（Virtual Address， VA）**来访问主存，这个虚拟地址在被送到存储器之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做**地址翻译（address translation）**。CPU芯片上叫做**存储器管理单元（Memory Management Unit，MMU）**的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容是由操作系统管理的。



## 地址空间

**地址空间**是一个非负整数地址的有序集合：
$$
\{0,1,2, ···\}
$$
如果地址空间中的整数是连续的，那么我们说它是一个***线性地址空间（linear address space）***。为了简化讨论，我们总是假设使用的是线性地址空间。在一个带虚拟存储器的系统中，CPU从一个有 N=2^n 个地址的地址空间中生成虚拟地址，这个地址空间称为**虚拟地址空间（virtual address space）**：
$$
\{0, 1, 2, ..., N-1\}
$$
一个地址空间的大小是由表示最大地址所需要的位数来描述的。









![av2TFU.png](https://s1.ax1x.com/2020/08/12/av2TFU.png)





PTBR (Page Table Base Register, 页表基址寄存器)

VAS 虚拟地址空间

PAS 物理地址空间



VA 虚拟地址

PA 物理地址





PPN

PPO



PA

PTE 页表条目

PTEA 页表条目地址

MMU





