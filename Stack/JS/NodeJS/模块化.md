# 模块化

## 1.	JavaScript的变迁和缺陷

JavaScript诞生之初旨在作为网页脚本，它并不是一门真正的编程语言。由于创造仓促和要求尽量简单，所以它自身存在一些缺陷。

* 没有模块系统
* 标准库较少
* 没有标准接口
* 缺乏包管理系统

随着互联网的发展，JavaScript也承担起了越来越多的功能性，更多的用户需求在前端实现，JavaScript从表单校验跃迁到应用开发的级别上。JavaScript经历了工具类库、组件库、前端框架、前端应用的变迁，如图所示：



在这个变迁的过程中，JavaScript相较其他编程语言缺少模块化系统的缺点更加凸显。为了更好地组织业务逻辑，JavaScript不断被类聚和抽象，于是开始了对JavaScript进行模块化的进程。



## 2.	模块化进程

### 恼人的命名冲突

### 繁琐的文件依赖

### CommonJS 社区

### 2.1	CommonJS规范

#### 2.1.1	规范

CommonJS对模块的定义主要分为：模块引用、模块定义和模块标识。

*1.	模块引用*

```js
var math = require('math');
```

在CommonJS规范中，存在require()方法，这个方法接受模块标识，以此引入一个模块的API到当前上下文中。

*2.	模块定义*

```js
// math.js
exports.add = function () {
    var sum = 0, 
        i = 0,
        args = arguments,
        l = args.length;
    while (i < l) {
        sum += args[i++];
    }
    return sum;
};

// program.js
var math = require('math');
exports.increment = function (val) {
    return math.add(val, 1);
};
```

在NodeJS中，一个文件就是一个模块。在模块中存在一个module对象，它代表模块自身，exports是module的属性。exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。

*3.	模块标识*

方法require()接受的参数就是模块标识，它必须是符合小驼峰命名的字符串。

![模块定义]()

#### 2.1.2	Node的模块实现

Node在实现中并非完全按照规范实现，而是对模块规范进行了一定的取舍，同时加入                                                  了少许自身需要的特性。

在Node中引入模块，需要经历三个步骤：

* 路径分析
* 文件定位
* 编译执行

在Node中，模块分为两类：

* Node提供的核心模块
* 用户编写的文件模块。



*模块优先从缓存加载*

Node对引入过的模块都会进行缓存，以减少二次引入的开销。Node缓存的是编译和执行之后的对象。无论是核心模块还是文件模块，Node都一律采用缓存优先的方式，不同的是核心模块的缓存检查先于文件模块的缓存检查。

*路径分析*





### AMD规范和RequireJS

### CMD规范和SeaJS



## 3.	CommonJS的模块规范

